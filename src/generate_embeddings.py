import os
import pandas as pd
from openai import AzureOpenAI
from dotenv import load_dotenv
from tqdm import tqdm
import re

# --- Environment and Configuration Setup ---
load_dotenv() # Load environment variables from .env file

# Azure OpenAI client initialization
# Ensure AZURE_OPENAI_ENDPOINT, AZURE_OPENAI_API_KEY, and AZURE_OPENAI_API_VERSION are set in .env
AZURE_OPENAI_ENDPOINT = os.getenv("AZURE_OPENAI_ENDPOINT")
AZURE_OPENAI_API_KEY = os.getenv("AZURE_OPENAI_API_KEY")
AZURE_OPENAI_API_VERSION = os.getenv("AZURE_OPENAI_API_VERSION")
EMBEDDING_DEPLOYMENT_NAME = os.getenv("AZURE_OPENAI_EMBEDDING_DEPLOYMENT_NAME")

INPUT_CSV_PATH = "data/cleaned_incidents.csv"
OUTPUT_CSV_PATH = "embeddings/cleaned_incidents_with_embeddings.csv" # Updated path

if not all([AZURE_OPENAI_ENDPOINT, AZURE_OPENAI_API_KEY, AZURE_OPENAI_API_VERSION, EMBEDDING_DEPLOYMENT_NAME]):
    raise ValueError("Azure OpenAI environment variables are not fully configured. Please check your .env file.")

client = AzureOpenAI(
    azure_endpoint=AZURE_OPENAI_ENDPOINT,
    api_key=AZURE_OPENAI_API_KEY,
    api_version=AZURE_OPENAI_API_VERSION
)

# --- Text Cleaning Function ---
def clean_text(text: str) -> str:
    """
    Cleans input text by converting to lowercase, removing excess whitespace,
    and stripping characters not matching a-z, 0-9, space, comma, period, exclamation, or question mark.

    Args:
        text: The input string to clean.

    Returns:
        The cleaned string. Returns an empty string if input is not a string.
    """
    if not isinstance(text, str):
        return ""  # Return empty string for non-string inputs
    text = text.lower() # Convert to lowercase
    text = re.sub(r'\s+', ' ', text)
    text = re.sub(r'\s+', ' ', text) # Replace multiple spaces with a single space
    text = re.sub(r'[^a-z0-9 .,!?]', '', text) # Remove unwanted characters
    return text.strip() # Remove leading/trailing whitespace

# --- Main Script Logic ---
if __name__ == "__main__":
    print(f"Loading data from {INPUT_CSV_PATH}...")
    df = pd.read_csv(INPUT_CSV_PATH)

    if 'combined_text' not in df.columns:
        raise ValueError(f"'combined_text' column not found in {INPUT_CSV_PATH}. Please ensure it's generated by preprocess_data.py.")

    # Clean the text column that will be used for generating embeddings
    print("Cleaning text data...")
    df['cleaned_text'] = df['combined_text'].apply(clean_text)

    # Generate embeddings for each entry in the 'cleaned_text' column
    embeddings = []
    print(f"Generating embeddings using Azure OpenAI model '{EMBEDDING_DEPLOYMENT_NAME}'...")

    # Iterate through texts with a progress bar via tqdm
    for text_content in tqdm(df['cleaned_text'], total=len(df), desc="Generating Embeddings"):
        if not text_content or text_content.isspace(): # Handle empty or whitespace-only strings
            embeddings.append(None) # Append None if text is empty to maintain row alignment
            continue
        try:
            # Call Azure OpenAI API to get embeddings
            response = client.embeddings.create(
                model=EMBEDDING_DEPLOYMENT_NAME,
                input=text_content
            )
            embedding_vector = response.data[0].embedding
            embeddings.append(embedding_vector)
        except Exception as e:
            print(f"Error generating embedding for text: '{text_content[:50]}...'. Error: {e}")
            embeddings.append(None) # Append None in case of error

    # Add the generated embeddings as a new column in the DataFrame
    df['embedding'] = embeddings
    print("Embeddings generated.")

    # Ensure the output directory exists
    output_dir = os.path.dirname(OUTPUT_CSV_PATH)
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        print(f"Created directory: {output_dir}")

    # Save the DataFrame with embeddings to a new CSV file
    df.to_csv(OUTPUT_CSV_PATH, index=False)
    print(f"Embedding generation complete! Data with embeddings saved to {OUTPUT_CSV_PATH}")
    print(f"\nSample of data with embeddings (first 5 rows):")
    print(df.head())

